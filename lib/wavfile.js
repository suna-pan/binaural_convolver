// Generated by CoffeeScript 1.10.0
(function() {
  var WAV_HEADER_LENGTH;

  WAV_HEADER_LENGTH = 45;

  window.WavFile = (function() {
    var littleEndian;

    function WavFile(file) {
      this.file = file;
      this.header = null;
      this.current = WAV_HEADER_LENGTH - 1;
    }

    littleEndian = function(data) {
      var d, j, len, res, shift;
      res = 0;
      shift = 0;
      for (j = 0, len = data.length; j < len; j++) {
        d = data[j];
        res += d << shift;
        shift += 8;
      }
      return res;
    };

    WavFile.prototype.loadHeader = function(success, fail) {
      var blob, me, reader, setHeader, start, stop;
      me = this;
      setHeader = function(h) {
        return me.header = h;
      };
      reader = new FileReader();
      reader.onloadend = function(evt) {
        var data, fileSize, fmtBitPerSample, fmtBlockBound, fmtBytePerSec, fmtCh, fmtCode, fmtSamplingRate, fmtSize, fmtWaveSize, h, raw, strData, strRIFF, strWAVE;
        if (evt.target.readyState !== FileReader.DONE) {
          return;
        }
        raw = evt.target.result;
        data = new Uint8Array(raw);
        if (data.length !== WAV_HEADER_LENGTH) {
          fail(2);
          return;
        }
        strRIFF = String.fromCharCode.apply("", data.slice(0, 4));
        if (strRIFF !== "RIFF") {
          fail(2);
          return;
        }
        strWAVE = String.fromCharCode.apply("", data.slice(8, 12));
        if (strWAVE !== "WAVE") {
          fail(2);
          return;
        }
        strData = String.fromCharCode.apply("", data.slice(36, 40));
        if (strData !== "data") {
          fail(2);
          return;
        }
        fileSize = littleEndian.call(this, data.slice(4, 8));
        fmtSize = littleEndian.call(this, data.slice(16, 20));
        fmtCode = littleEndian.call(this, data.slice(20, 22));
        fmtCh = littleEndian.call(this, data.slice(22, 24));
        fmtSamplingRate = littleEndian.call(this, data.slice(24, 28));
        fmtBytePerSec = littleEndian.call(this, data.slice(28, 32));
        fmtBlockBound = littleEndian.call(this, data.slice(32, 34));
        fmtBitPerSample = littleEndian.call(this, data.slice(34, 36));
        fmtWaveSize = littleEndian.call(this, data.slice(40, 44));
        h = {
          fileSize: fileSize + 8,
          fmtSize: fmtSize,
          fmtCode: fmtCode,
          fmtCh: fmtCh,
          fmtSamplingRate: fmtSamplingRate,
          fmtBytePerSec: fmtBytePerSec,
          fmtBlockBound: fmtBlockBound,
          fmtBitPerSample: fmtBitPerSample,
          fmtWaveSize: fmtWaveSize
        };
        setHeader(h);
        return success(h);
      };
      start = 0;
      stop = WAV_HEADER_LENGTH;
      blob = null;
      if (this.file.webkitSlice) {
        blob = this.file.webkitSlice(start, stop);
      } else if (this.file.mozSlice) {
        blob = this.file.mozSlice(start, stop);
      } else {
        blob = this.file.slice(start, stop);
      }
      if (blob !== null) {
        return reader.readAsArrayBuffer(blob);
      } else {
        return fail(1);
      }
    };

    WavFile.prototype.next512 = function(success, fail) {
      var blob, blockBound, bp2, bytePerSample, ch, last, reader, refSize, start, stop;
      blockBound = this.header.fmtBlockBound;
      bytePerSample = this.header.fmtBitPerSample / 8;
      bp2 = bytePerSample * 2;
      ch = this.header.fmtCh;
      refSize = bytePerSample * 512 * ch;
      last = false;
      reader = new FileReader();
      reader.onloadend = function(evt) {
        var data, i, j, k, raw, ref, ref1, result, results, tmp, tmpL, tmpR;
        raw = evt.target.result;
        data = new Uint8Array(raw);
        result = (function() {
          results = [];
          for (var j = 0, ref = data.length / (ch * bytePerSample); 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
          return results;
        }).apply(this);
        for (i = k = 0, ref1 = data.length / (ch * bytePerSample); 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
          if (ch === 1) {
            tmp = new window.Complex(littleEndian.call(this, data.slice(i * blockBound, i * blockBound + bytePerSample)), 0);
            result[i] = [tmp, tmp];
          } else {
            tmpL = littleEndian.call(this, data.slice(i * blockBound, i * blockBound + bytePerSample));
            tmpR = littleEndian.call(this, data.slice(i * blockBound + bytePerSample, i * blockBound + bp2));
            result[i] = [new window.Complex(tmpL, 0), new window.Complex(tmpR, 0)];
          }
          if (result[i][0].re > 0x7fff) {
            result[i][0].re = -(~(result[i][0].re - 1) & 0xffff);
          }
          if (result[i][1].re > 0x7fff) {
            result[i][1].re = -(~(result[i][1].re - 1) & 0xffff);
          }
        }
        return success(last, result, refSize);
      };
      start = this.current;
      stop = this.current + 512 * this.header.fmtBlockBound;
      this.current = stop;
      if (this.current - (WAV_HEADER_LENGTH - 1) >= this.header.fmtWaveSize) {
        last = true;
        this.current = WAV_HEADER_LENGTH - 1;
      }
      if (this.file.webkitSlice) {
        blob = this.file.webkitSlice(start, stop);
      } else if (this.file.mozSlice) {
        blob = this.file.mozSlice(start, stop);
      } else {
        blob = this.file.slice(start, stop);
      }
      if (blob !== null) {
        return reader.readAsArrayBuffer(blob);
      } else {
        return fail(1);
      }
    };

    WavFile.prototype.genWavHeader = function(waveSize) {
      var buf, fileSize;
      fileSize = waveSize + WAV_HEADER_LENGTH - 8;
      buf = String.fromCharCode(0x52, 0x49, 0x46, 0x46);
      buf += String.fromCharCode(fileSize & 0xff, (fileSize >> 8) & 0xff, (fileSize >> 16) & 0xff, (fileSize >> 24) & 0xff);
      buf += String.fromCharCode(0x57, 0x41, 0x56, 0x45, 0x66, 0x6d, 0x74, 0x20, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x44, 0xac, 0x00, 0x00, 0x10, 0xb1, 0x02, 0x00, 0x04, 0x00, 0x10, 0x00, 0x64, 0x61, 0x74, 0x61);
      buf += String.fromCharCode(waveSize & 0xff, (waveSize >> 8) & 0xff, (waveSize >> 16) & 0xff, (waveSize >> 24) & 0xff);
      return buf;
    };

    return WavFile;

  })();

}).call(this);
